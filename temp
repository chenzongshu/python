```
# Python测试与Mock

标签（空格分隔）： python

---

自动化测试在软件开发的过程中是非常重要的, 在开发,重构中可以迅速发现bug, 降低后期运维成本

测试框架有pytest和原生的unittest, pytest使用较方便, 下面介绍

# pytest

## 安装

直接pip安装

```
pip install pytest
```

## 使用

pytest会自动从**`当前目录`**寻找测试文件来执行测试用例, 即在测试文件所在目录直接执行

```
pytest
```

测试文件有如下约束:

- 所有的单测文件名都需要满足`test_*.py`格式或`*_test.py`格式。
- 在单测文件中，可以包含`test_`开头的函数，也可以包含`Test`开头的类, 类不能带有 init 方法。
- 在单测类中，可以包含一个或多个`test_`开头的函数。
- 断言基本使用`assert`

具体参数可以使用命令

```
pytest -h
```

一般可以使用详细测试模式查看所有打印输出

```
pytest -v -s test_module.py
```

## pytest高级特性fixture

什么是fixture, 简单的说, 就是执行某段代码之前的初始化, 类似于构造函数和析构函数的结合体

可以把fixture看做是资源，在你的测试用例执行之前需要去配置这些资源，执行完后需要去释放资源

把一个函数定义为Fixture很简单，只能在函数声明之前加上“@pytest.fixture”。其他函数要来调用这个Fixture，只用把它当做一个输入的参数即可

```
# test_fixture_basic.py
import pytest

@pytest.fixture()
def before():
    print '\nbefore each test'

def test_1(before):
    print 'test_1()'

def test_2(before):
    print 'test_2()'
    assert 0
```

会输出

```
......
test_fixture_basic.py::test_1
before each test
test_1()
PASSED
test_fixture_basic.py::test_2
before each test
test_2()
FAILED
```

test_1和test_2运行之前都调用了before，也就是before执行了两次。默认情况下，fixture是每个测试用例如果调用了该fixture就会执行一次的。

### autouse

还有一个参数是`autouse`, 当设置为True时， 在一个session内的所有的test都会自动调用这个fixture。 权限大，责任也大，所以用该功能时也要谨慎小心

```
import time
import pytest

@pytest.fixture(scope="module", autouse=True)
def mod_header(request):
    print('\n-----------------')
    print('module      : %s' % request.module.__name__)
    print('-----------------')

@pytest.fixture(scope="function", autouse=True)
def func_header(request):
    print('\n-----------------')
    print('function    : %s' % request.function.__name__)
    print('time        : %s' % time.asctime())
    print('-----------------')

def test_one():
    print('in test_one()')

def test_two():
    print('in test_two()')

```

输出为:

```
[root@vm1 pytest]# pytest -v -s test_1.py
......

test_1.py::test_one
-----------------
module      : test_1
-----------------

-----------------
function    : test_one
time        : Tue Mar  5 20:05:27 2019
-----------------
in test_one()
PASSED
test_1.py::test_two
-----------------
function    : test_two
time        : Tue Mar  5 20:05:27 2019
-----------------
in test_two()
PASSED
```

# Mock

## Mock是什么

Mock是就是在单元测试中, 模拟对象,函数接口的方法, 特别是系统与外部第三方有大量交互调用时大展身手

## 为什么用Mock

可能有同学说为什么用Mock, 真实第三方环境不是更贴近生产环境, 理想很美好, 现实总是血淋漓, 举几个栗子吧

- 复杂云环境搭建不易, 需要资源太多, 多个团队共用一个开发环境, 几十号人在上面折腾, 环境长期不可用, 你要测试自己的功能, 呵呵, 图杨图森破
- 某些功能就不方便真实测试, 比如需要邮件告警, 在自动化测试的时候每天几十封邮件发给别人, 可能还伴随电话, 估计你同事唯一想做的事情就是拿你祭天

这个时候, 你就需要Mock来模拟那些你眼中的"垃圾"的交互服务, 有种掌握一切的感觉, 相信我, 这种感觉会上头的......

## Mock安装

在Python 3.3以前的版本中，需要另外安装mock模块，可以使用pip命令来安装：

```
$ sudo pip install mock
```

然后在代码中就可以直接import进来：
```
import mock
```

从Python 3.3开始，mock模块已经被合并到标准库中，被命名为unittest.mock，可以直接import进来使用：

```
from unittest import mock
```

## Mock使用

有 **`Mock`** 和 **`MagicMock`** 两个常用子类

```
class Mock(spec=None, side_effect=None, return_value=DEFAULT, wraps=None, name=None, spec_set=None, **kwargs)
```

- name: 这个是用来命名一个mock对象，只是起到标识作用，当你print一个mock对象的时候，可以看到它的name。
- return_value: 这个字段可以指定一个值（或者对象），当mock对象被调用时，如果side_effect函数返回的是DEFAULT，则对mock对象的调用会返回return_value指定的值。
- side_effect: 这个参数指向一个可调用对象，一般就是函数。当mock对象被调用时，如果该函数返回值不是DEFAULT时，那么以该函数的返回值作为mock对象调用的返回值。

来试试mock:

```
>>> class Foo():
...     def echo(self, *args):
...         return "hello"
...
>>> foo = Foo()
>>>
>>> foo.echo()
'hello'
>>>
>>> foo.echo=mock.Mock()
>>> foo.echo.return_value="mock value"
>>> foo.echo()
'mock value'
>>> foo.echo(1,2)
'mock value'
```

注意,被mock之后, foo.echo类型变成了Mock类

```
>>> type(foo.echo)
<class 'mock.mock.Mock'>
```

有如下方法:

```
>>> dir(foo.echo)
['assert_any_call', 'assert_called', 'assert_called_once', 'assert_called_once_with', 'assert_called_with', 'assert_has_calls', 'assert_not_called', 'attach_mock', 'call_args', 'call_args_list', 'call_count', 'called', 'configure_mock', 'method_calls', 'mock_add_spec', 'mock_calls', 'reset_mock', 'return_value', 'side_effect']
```

可以看到其中一些值

```
>>> foo.echo.called
True
>>> foo.echo.call_count
3
```

## side_effect

side_effect 是一个非常有用的参数，大大提高了 mock 返回值的灵活性，它可以是一个异常、函数或者可迭代对象。例如返回一个异常：

```
>>> except_mock = mock.Mock(side_effect=Exception('Boom!'))
>>>
>>> except_mock()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/site-packages/mock/mock.py", line 1062, in __call__
    return _mock_self._mock_call(*args, **kwargs)
  File "/usr/lib/python2.7/site-packages/mock/mock.py", line 1118, in _mock_call
    raise effect
Exception: Boom!
```

当 side_effect 为迭代对象时

```
>>> iter_mock = mock.Mock(side_effect=[1, 2, 3])
>>>
>>> iter_mock()
1
>>> iter_mock()
2
>>> iter_mock()
3
>>> iter_mock()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/site-packages/mock/mock.py", line 1062, in __call__
    return _mock_self._mock_call(*args, **kwargs)
  File "/usr/lib/python2.7/site-packages/mock/mock.py", line 1121, in _mock_call
    result = next(effect)
  File "/usr/lib/python2.7/site-packages/mock/mock.py", line 109, in next
    return _next(obj)
StopIteration
```

side_effect 为函数时

```
>>> def side_effect(value):
...     return value
...
>>>
>>> side_effect_mock = mock.Mock(side_effect=side_effect)
>>> side_effect_mock(1)
1
>>> side_effect_mock("hello world!")
'hello world!'
```

# Mock Server

还有一种办法, 即做一个mocker server, 模拟第三方服务响应, 可以用于第三方环境模拟, 有条件可以使用线上平台比如`easy-mock`, `eolinker mock`等, 没条件的自己用flask简单写一个

> mock函数多用于测试用例, mock server用于第三方服务的模拟

python可以使用flask简单模拟

首先安装flask

```
pip install flask
```

## get请求

简单示例

```
from flask import abort, jsonify, Flask, request, Response

app = Flask(__name__)

tasks = {
    "data": {
        "loginName": "admin",
        "roles": 1,
        "permissions": 1,
        "active": 1
    },
    "stateCode": {
        "code": 0,
        "desc": "成功"
    },
    "statusText": "成功",
    "timestamp": "1500531770453",
    "success": 1
}

@app.route("/task", methods=['GET'])
def get_all_task():
    return jsonify(tasks)
    
if __name__ == "__main__":
    if __name__ == "__main__":
    app.run(
        host = "127.0.0.1",
        port = 8989,
        debug = True
        )
```

启动服务

```
python test.py
```

测试

```
curl -i "http://127.0.0.1:8989/task"
```

## post

详细可以看flask示例, 简单示例可对上面进行简单改造如下:

```
......
@app.route('/v1/testMock', methods=['GET', 'POST'])
def app_call_back():
    if request.method == 'GET':
        return jsonify(tasks)
    else:
        test_data = request.form['params']
        return jsonify(test_data)
......
```

测试

```
curl -d "params=test_mock" "http://127.0.0.1:8989/v1/testMock
```

默认Flask调用jsonify返回结果是utf8，如果需要返回支持中文显示，只需要在app = Flask(name)下增加一行：

```
app.config['JSON_AS_ASCII'] = False
```


```
